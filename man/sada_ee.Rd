% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sada_ee.R
\name{sada_ee}
\alias{sada_ee}
\title{General SADA estimator for user specified estimating equations}
\usage{
sada_ee(
  Y,
  Yhat_labeled,
  Yhat_unlabeled,
  X_labeled,
  X_unlabeled,
  s_fun,
  beta_init = NULL,
  level = 0.95,
  bb_control = list()
)
}
\arguments{
\item{Y}{Numeric vector of outcomes for the labeled data of length n.}

\item{Yhat_labeled}{Numeric matrix of size n times K containing black box
predictions for the labeled observations, one column per prediction
source.}

\item{Yhat_unlabeled}{Numeric matrix of size m times K containing black box
predictions for the unlabeled observations. Must have the same number
of columns as \code{Yhat_labeled}.}

\item{X_labeled}{Covariate matrix for the labeled data, of size n times q.
This matrix is passed directly to \code{s_fun}.}

\item{X_unlabeled}{Covariate matrix for the unlabeled data, of size m times q.
Must have the same number of columns as \code{X_labeled}.}

\item{s_fun}{User supplied function computing individual estimating
equation contributions. It must have the form
\code{s_fun(beta, X, Y)}, where \code{beta} is a numeric parameter
vector of length p, \code{X} is an n times q matrix, and \code{Y} is a
numeric vector of length n. The function must return an n times p matrix
whose i th row is s(x_i, y_i; beta).}

\item{beta_init}{Optional numeric vector giving the initial value for the
parameter beta with length p. If omitted, the function attempts to infer
the dimension p and uses a zero vector of length p whenever this is
possible. If the dimension cannot be inferred safely, the user is asked
to supply \code{beta_init} explicitly.}

\item{level}{Confidence level for confidence intervals. Default is 0.95.}

\item{bb_control}{Optional list of control parameters passed to
\code{BBsolve} via its \code{control} argument.}
}
\value{
An object of class \code{"sada_ee"}, which is a list containing
\describe{
\item{est}{Final SADA estimate of the parameter vector.}
\item{sd}{Estimated standard errors for each component of the estimator.}
\item{ci}{Matrix of pointwise confidence intervals for the estimator, with
columns \code{lower} and \code{upper}.}
\item{vcov}{Estimated covariance matrix of the SADA estimator. This is the
same matrix returned by the method \code{vcov.sada_ee}.}
\item{beta_prelim}{Preliminary estimator obtained by solving the labeled only
estimating equation.}
\item{w_opt}{List of length K. Each element is a p times p matrix containing
the optimal SADA weight block for the corresponding prediction source.}
\item{w_opt_full}{Full optimal weight matrix of dimension Kp times p obtained
by stacking all per predictor blocks.}
\item{K}{Number of black box prediction sources.}
\item{bbsolve_prelim}{Selected output of \code{BBsolve} for the preliminary estimator.}
\item{bbsolve_sada}{Selected output of \code{BBsolve} for the SADA estimator.}
\item{call}{The matched function call.}
}
}
\description{
Implements a general SADA estimator for parameters defined by estimating
equations. The user supplies a score function \code{s_fun}, and the
function automatically constructs the SADA adjusted estimating equation
using labeled data, unlabeled data and multiple black box predictions.
The resulting parameter estimate is obtained by solving the SADA estimating
equation via \code{BBsolve}, and a sandwich type variance estimator is
used to provide standard errors and confidence intervals.
Objects returned by \code{sada_ee} have methods for \code{summary}
and \code{vcov}.
}
\examples{
## Example: logistic regression via estimating equations
## Target: solve E[ X_i times { Y_i minus expit(X_i^T beta) } ] = 0

set.seed(1)

n <- 100   # labeled sample size
m <- 500   # unlabeled sample size

## Dimension of beta including intercept
p <- 3

## Covariates for labeled and unlabeled data
X_labeled <- cbind(
  1,
  matrix(rnorm(n * (p - 1)), nrow = n, ncol = p - 1)
)
X_unlabeled <- cbind(
  1,
  matrix(rnorm(m * (p - 1)), nrow = m, ncol = p - 1)
)

## True regression coefficients
beta_true <- c(-0.5, 1, -1)

## Generate labeled outcomes from a logistic regression model
linpred_labeled <- as.numeric(X_labeled \%*\% beta_true)
prob_labeled <- plogis(linpred_labeled)
Y <- rbinom(n, size = 1, prob = prob_labeled)

## Build full design matrix labeled plus unlabeled
X_full <- rbind(X_labeled, X_unlabeled)
N <- n + m

## Underlying linear predictor and probabilities for all data
linpred_full <- as.numeric(X_full \%*\% beta_true)
prob_full <- plogis(linpred_full)

## Generate an unobserved true outcome for all N samples
Y_full <- rbinom(N, size = 1, prob = prob_full)

## Construct K = 2 black box prediction sources for the probability
K <- 2
eta1_full <- linpred_full + rnorm(N, sd = 0.5)
eta2_full <- linpred_full + rnorm(N, sd = 1.0)
Yhat1_full <- plogis(eta1_full)
Yhat2_full <- plogis(eta2_full)

## Here the black box predictions are probabilities
## For sada_ee we treat them as pseudo outcomes in [0, 1]

Yhat_labeled   <- cbind(Yhat1_full[1:n],     Yhat2_full[1:n])
Yhat_unlabeled <- cbind(Yhat1_full[(n+1):N], Yhat2_full[(n+1):N])

## Score function for logistic regression:
## s(beta, X, Y)_i = X_i times ( Y_i minus expit(X_i^T beta) )
s_fun <- function(beta, X, Y) {
  X <- as.matrix(X)
  linpred <- as.numeric(X \%*\% beta)
  mu <- plogis(linpred)
  X * (Y - mu)
}

## Initial value for beta
beta_init <- rep(0, p)

fit_logit <- sada_ee(
  Y = Y,
  Yhat_labeled = Yhat_labeled,
  Yhat_unlabeled = Yhat_unlabeled,
  X_labeled = X_labeled,
  X_unlabeled = X_unlabeled,
  s_fun = s_fun,
  beta_init = beta_init,
  level = 0.95
)

## SADA estimate for the logistic regression coefficients
fit_logit$est

## Standard errors and confidence intervals
fit_logit$sd
fit_logit$ci

## Summary and covariance matrix
summary(fit_logit)
vcov(fit_logit)

## Optimal SADA weight matrices, one per prediction source
fit_logit$w_opt$pred1
fit_logit$w_opt$pred2

}
